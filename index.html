<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Online Snake (SSE)</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: Arial, sans-serif; margin: 16px; background: #f8fbf7; color: #1a1a1a; }
    .hero {
      display: flex;
      align-items: center;
      gap: 16px;
      border: 1px solid #d9e6d2;
      border-radius: 12px;
      padding: 14px;
      margin-bottom: 16px;
      background: #ffffff;
    }
    .hero img {
      width: 72px;
      height: 72px;
      object-fit: contain;
      border-radius: 10px;
      background: #eef6e9;
      padding: 6px;
    }
    .hero h1 { margin: 0 0 6px 0; font-size: 26px; }
    .hero p { margin: 0; color: #2f4730; }
    .layout { display: flex; gap: 16px; align-items: flex-start; width: 100%; min-width: 0; }
    #left { width: 260px; max-width: 260px; flex: 0 0 260px; }
    #game { flex: 1 1 auto; width: 100%; min-width: 0; }
    #game-main {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      min-width: 0;
    }
    #view-controls {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: wrap;
      gap: 8px;
      padding: 6px 8px;
      border: 1px solid #d7dfd5;
      border-radius: 8px;
      background: #ffffff;
    }
    #view-controls button {
      padding: 6px 10px;
      min-width: 44px;
    }
    #view-help {
      color: #4b5b49;
      font-size: 12px;
      margin-left: 4px;
      white-space: normal;
    }
    #public-view-hint {
      display: none;
      color: #5a3e1b;
      background: #fff5e5;
      border: 1px solid #f0d6a7;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 12px;
      margin-left: 6px;
    }
    #debug-overlay {
      display: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 12px;
      line-height: 1.35;
      border: 1px solid #d5d5d5;
      background: rgba(255, 255, 255, 0.92);
      color: #222;
      border-radius: 8px;
      padding: 8px;
    }
    #game-board-wrap {
      overflow: auto;
      width: 100%;
      max-width: 100%;
      min-width: 0;
      height: min(70vh, 560px);
      padding-bottom: 4px;
      border: 1px solid #d7dfd5;
      border-radius: 8px;
      background: #fbfdf9;
    }

    #game-board {
      display: grid;
      gap: 1px;
      background: #ccc;
      width: max-content;
      user-select: none;
    }
    .cell {
      width: 18px;
      height: 18px;
      background: #f3f3f3;
    }
    .food { background: #ff4444 !important; }

    .snake-cell { background: #00aa00; }

    .panel { border: 1px solid #ddd; padding: 12px; border-radius: 8px; margin-bottom: 12px; }
    .compact-panel {
      margin-bottom: 0;
      padding: 10px;
      background: #ffffff;
    }
    .compact-panel h3 {
      margin: 0 0 8px 0;
      font-size: 15px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px 12px;
    }
    .row { margin: 6px 0; }
    input {
      width: 100%;
      max-width: 100%;
      padding: 6px;
      box-sizing: border-box;
    }
    button { padding: 8px 10px; cursor: pointer; }

    .snake-item {
      border: 1px solid #ddd;
      padding: 8px;
      border-radius: 8px;
      margin: 6px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .snake-item.active { outline: 2px solid #333; }
    .snake-item label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .snake-item input.watch-toggle {
      max-width: 100%;
    }
    .badge { width: 16px; height: 16px; border-radius: 4px; display: inline-block; margin-right: 8px; }
    small { color: #666; }

    @media (max-width: 980px) {
      .layout {
        flex-direction: column;
      }
      #left {
        width: 100%;
        max-width: none;
        flex: 1 1 auto;
      }
      #game {
        width: 100%;
      }
    }

    @media (max-width: 640px) {
      body {
        margin: 10px;
      }
      .hero {
        flex-direction: column;
        align-items: flex-start;
      }
      .hero img {
        width: 64px;
        height: 64px;
      }
    }
  </style>
</head>
<body>
  <div class="hero">
    <img src="src/images/snake_logo.png" alt="Terrarium Snake Club logo" />
    <div>
      <h1>Terrarium Snake Club</h1>
      <p>Welcome to the new world of gaming! We are currently testing the project, and it will be available very soon. Keep checking back!</p>
    </div>
  </div>

  <div class="layout">
  <div id="left">
    <div class="panel">
      <div class="row"><strong>Login (optional)</strong></div>
      <div class="row"><input id="username" placeholder="username (user1)" /></div>
      <div class="row"><input id="password" type="password" placeholder="password (pass1)" /></div>
      <div class="row"><button id="loginBtn">Login</button></div>
      <div class="row"><small id="authStatus">Not logged in (watch-only)</small></div>
    </div>

    <div class="panel">
      <div class="row"><strong>My Snakes</strong></div>
      <div id="mySnakes"></div>
      <div class="row"><button id="createSnakeBtn" disabled>Create Snake</button></div>
      <div class="row"><small>Controls: W/A/S/D move selected snake, P pause selected snake</small></div>
    </div>
  </div>

  <div id="game">
    <div id="game-main">
      <div class="panel compact-panel">
        <h3>Economy (Read-Only)</h3>
        <div class="stats-grid">
          <div title="Total issued cells">Money Supply (M): <span id="ecoM">—</span></div>
          <div title="Cost multiplier (read-only for now)">Price Index (P): <span id="ecoP">—</span></div>
          <div title="Money growth this period">Inflation (pi): <span id="ecoPi">—</span></div>
          <div title="World area implied by money supply">World Size (A_world): <span id="ecoAWorld">—</span></div>
          <div title="Slack capacity">Free Space (M_white): <span id="ecoMWhite">—</span></div>
        </div>
      </div>
      <div id="view-controls">
        <strong>View</strong>
        <button id="zoomInBtn" type="button">+ Zoom In</button>
        <button id="zoomOutBtn" type="button">- Zoom Out</button>
        <button id="zoomResetBtn" type="button">Reset</button>
        <small id="view-help">Zoom: +/- buttons. Reset returns to default view.</small>
        <small id="public-view-hint">Login to control camera &amp; zoom.</small>
      </div>
      <div id="debug-overlay"></div>
      <div id="game-board-wrap">
        <div id="game-board"></div>
      </div>
      <div class="panel compact-panel">
        <h3>Live Game</h3>
        <div class="stats-grid">
          <div>Tick: <span id="tick">0</span></div>
          <div>Expected speed: <span id="expectedTickHz">-</span> tick/s</div>
          <div>Actual speed: <span id="actualTickHz">-</span> tick/s</div>
          <div><small id="ecoStatus">Economy: loading...</small></div>
        </div>
      </div>
    </div>
  </div>
  </div>

<script>
  const API_BASE = window.location.protocol === "file:" ? "http://127.0.0.1:8080" : "";
  const apiPath = (path) => `${API_BASE}${path}`;
  const DEBUG_MODE = new URLSearchParams(window.location.search).get("debug") === "1";
  const BASE_CELL_SIZE = 18;

  class Camera {
    constructor() {
      this.x = 20;
      this.y = 10;
      this.zoom = 1.0;
    }
    setCenter(x, y) {
      this.x = Number.isFinite(x) ? x : this.x;
      this.y = Number.isFinite(y) ? y : this.y;
    }
    setZoom(z) {
      const next = Number.isFinite(z) ? z : this.zoom;
      this.zoom = Math.max(0.25, Math.min(4.0, next));
    }
    resetToDefault(worldW, worldH) {
      this.setCenter(Math.floor(worldW / 2), Math.floor(worldH / 2));
      this.setZoom(1.0);
    }
    worldToScreen(wx, wy) {
      return { sx: (wx - this.x) * this.zoom, sy: (wy - this.y) * this.zoom };
    }
  }

  const TOKEN_STORAGE_KEY = "snake_auth_token";
  const USER_ID_STORAGE_KEY = "snake_auth_user_id";
  const SELECTED_SNAKE_STORAGE_KEY = "snake_selected_snake_id";
  const WATCHED_SNAKE_STORAGE_KEY = "snake_watched_snake_id";

  let token = localStorage.getItem(TOKEN_STORAGE_KEY);
  let myUserId = Number(localStorage.getItem(USER_ID_STORAGE_KEY));
  if (!Number.isFinite(myUserId) || myUserId <= 0) myUserId = null;
  let selectedSnakeId = Number(localStorage.getItem(SELECTED_SNAKE_STORAGE_KEY));
  if (!Number.isFinite(selectedSnakeId) || selectedSnakeId <= 0) selectedSnakeId = null;
  let watchedSnakeId = Number(localStorage.getItem(WATCHED_SNAKE_STORAGE_KEY));
  if (!Number.isFinite(watchedSnakeId) || watchedSnakeId <= 0) watchedSnakeId = null;
  let latestServerState = null;
  const stateBuffer = [];
  const streamSessionId = (window.crypto && crypto.randomUUID)
    ? crypto.randomUUID()
    : ("sid_" + Math.random().toString(36).slice(2));
  const camera = new Camera();

  let gridW = 40, gridH = 20;
  let cells = [];

  const board = document.getElementById("game-board");
  const boardWrap = document.getElementById("game-board-wrap");
  const tickEl = document.getElementById("tick");
  const expectedTickHzEl = document.getElementById("expectedTickHz");
  const actualTickHzEl = document.getElementById("actualTickHz");
  const ecoMEl = document.getElementById("ecoM");
  const ecoPEl = document.getElementById("ecoP");
  const ecoPiEl = document.getElementById("ecoPi");
  const ecoAWorldEl = document.getElementById("ecoAWorld");
  const ecoMWhiteEl = document.getElementById("ecoMWhite");
  const ecoStatusEl = document.getElementById("ecoStatus");
  const authStatus = document.getElementById("authStatus");
  const mySnakesEl = document.getElementById("mySnakes");
  const createSnakeBtn = document.getElementById("createSnakeBtn");
  const zoomInBtn = document.getElementById("zoomInBtn");
  const zoomOutBtn = document.getElementById("zoomOutBtn");
  const zoomResetBtn = document.getElementById("zoomResetBtn");
  const debugOverlayEl = document.getElementById("debug-overlay");
  const viewControlsEl = document.getElementById("view-controls");
  const publicViewHintEl = document.getElementById("public-view-hint");

  let lastTickSample = null;
  let expectedTickHz = null;
  const FALLBACK_EXPECTED_TICK_HZ = 10;
  let runtimeSpeedPollTimer = null;
  let economyPollTimer = null;
  let cameraPollTimer = null;
  let viewPollTimer = null;
  let latestSnapshotBytes = 0;
  let serverAoiChunks = 0;
  let debugModeLabel = "PUBLIC";
  let debugPublicChunk = { cx: 0, cy: 0 };
  let streamHandle = null;
  let suppressScrollSync = false;

  function buildBoard(w, h) {
    gridW = w; gridH = h;
    board.style.gridTemplateColumns = `repeat(${w}, ${Math.max(4, Math.round(BASE_CELL_SIZE * camera.zoom))}px)`;
    board.innerHTML = "";
    cells = [];
    for (let i = 0; i < w*h; i++) {
      const c = document.createElement("div");
      c.className = "cell";
      const side = Math.max(4, Math.round(BASE_CELL_SIZE * camera.zoom));
      c.style.width = `${side}px`;
      c.style.height = `${side}px`;
      board.appendChild(c);
      cells.push(c);
    }
  }

  function applyZoomToBoard() {
    const side = Math.max(4, Math.round(BASE_CELL_SIZE * camera.zoom));
    board.style.gridTemplateColumns = `repeat(${gridW}, ${side}px)`;
    for (const c of cells) {
      c.style.width = `${side}px`;
      c.style.height = `${side}px`;
    }
  }

  function idx(x,y){ return y*gridW + x; }

  function clearBoard() {
    for (const c of cells) {
      c.className = "cell";
      c.style.background = ""; // allow custom snake colors
    }
  }

  function drawFrame(state) {
    latestServerState = state;
    camera.worldToScreen(0, 0); // Keeps camera transform API active for renderer evolution.
    tickEl.textContent = state.tick;
    updateActualTickHz(state.tick);

    if (state.w !== gridW || state.h !== gridH || cells.length === 0) {
      buildBoard(state.w, state.h);
    }

    clearBoard();

    // foods
    for (const f of state.foods) {
      const i = idx(f.x, f.y);
      if (cells[i]) cells[i].classList.add("food");
    }

    // snakes
    for (const s of state.snakes) {
      for (const seg of s.body) {
        const i = idx(seg.x, seg.y);
        if (!cells[i]) continue;
        cells[i].classList.add("snake-cell");
        // color each snake
        cells[i].style.background = s.color;
      }
    }
    // Continuous follow is only active when watch checkbox is enabled.
    if (token && watchedSnakeId) {
      const followTarget = findSnakeHeadById(watchedSnakeId);
      if (followTarget) {
        camera.setCenter(followTarget.x, followTarget.y);
        centerViewportOnCamera();
      }
    }
  }

  function pushStateBuffer(state) {
    stateBuffer.push({ state, t: performance.now() });
    if (stateBuffer.length > 2) stateBuffer.shift();
  }

  function buildWorldView() {
    // v1 view layer: keep ring buffer ready for interpolation, render latest snapshot for now.
    if (stateBuffer.length === 0) return null;
    return stateBuffer[stateBuffer.length - 1].state;
  }

  function updateDebugOverlay() {
    if (!DEBUG_MODE) return;
    debugOverlayEl.style.display = "block";
    debugOverlayEl.textContent =
      `mode: ${debugModeLabel}\n` +
      `camera: x=${camera.x.toFixed(2)} y=${camera.y.toFixed(2)}\n` +
      `zoom: ${camera.zoom.toFixed(2)}\n` +
      `public_chunk: cx=${debugPublicChunk.cx} cy=${debugPublicChunk.cy}\n` +
      `aoi_chunks: ${serverAoiChunks}\n` +
      `last_snapshot_bytes: ${latestSnapshotBytes}`;
  }

  function updateActualTickHz(currentTick) {
    const now = performance.now();
    if (!lastTickSample) {
      lastTickSample = { tick: currentTick, t: now };
      return;
    }

    const dtMs = now - lastTickSample.t;
    const dTick = currentTick - lastTickSample.tick;
    if (dtMs >= 800 && dTick >= 0) {
      const hz = dTick / (dtMs / 1000);
      actualTickHzEl.textContent = hz.toFixed(2);
      lastTickSample = { tick: currentTick, t: now };
    }
  }

  async function loadRuntimeSpeed() {
    try {
      const res = await fetch(apiPath("/game/runtime"));
      if (!res.ok) throw new Error("runtime endpoint unavailable");
      const data = await res.json();
      if (typeof data.tick_hz === "number" && data.tick_hz > 0) {
        expectedTickHz = data.tick_hz;
        expectedTickHzEl.textContent = String(expectedTickHz);
        return;
      }
      throw new Error("runtime endpoint missing tick_hz");
    } catch (_) {
      // Fallback keeps local/prod UI readable when talking to an older backend binary.
      expectedTickHz = FALLBACK_EXPECTED_TICK_HZ;
      expectedTickHzEl.textContent = `${expectedTickHz} (fallback)`;
      // Stop repeated failing polls on older binaries that do not expose /game/runtime.
      if (runtimeSpeedPollTimer) {
        clearInterval(runtimeSpeedPollTimer);
        runtimeSpeedPollTimer = null;
      }
    }
  }

  function setEconomyFallback() {
    ecoMEl.textContent = "—";
    ecoPEl.textContent = "—";
    ecoPiEl.textContent = "—";
    ecoAWorldEl.textContent = "—";
    ecoMWhiteEl.textContent = "—";
    ecoStatusEl.textContent = "Economy unavailable";
    updateDebugOverlay();
  }

  function fmtInt(v) {
    if (!Number.isFinite(v)) return "—";
    return Math.trunc(v).toLocaleString();
  }

  async function loadEconomyState() {
    try {
      const res = await fetch(apiPath("/economy/state"));
      if (!res.ok) throw new Error("economy endpoint unavailable");
      const s = await res.json();
      ecoMEl.textContent = fmtInt(Number(s.M));
      ecoPEl.textContent = Number.isFinite(Number(s.P)) ? Number(s.P).toFixed(3) : "—";
      ecoPiEl.textContent = Number.isFinite(Number(s.pi)) ? Number(s.pi).toFixed(4) : "—";
      ecoAWorldEl.textContent = fmtInt(Number(s.A_world));
      ecoMWhiteEl.textContent = fmtInt(Number(s.M_white));
      ecoStatusEl.textContent = "Economy: live";
      updateDebugOverlay();
    } catch (_) {
      setEconomyFallback();
    }
  }

  async function api(path, opts={}) {
    const headers = opts.headers || {};
    headers["Content-Type"] = "application/json";
    if (token) headers["Authorization"] = "Bearer " + token;
    const res = await fetch(apiPath(path), { ...opts, headers });
    if (res.status === 401 && token) {
      token = null;
      myUserId = null;
      selectedSnakeId = null;
      watchedSnakeId = null;
      localStorage.removeItem(TOKEN_STORAGE_KEY);
      localStorage.removeItem(USER_ID_STORAGE_KEY);
      localStorage.removeItem(SELECTED_SNAKE_STORAGE_KEY);
      localStorage.removeItem(WATCHED_SNAKE_STORAGE_KEY);
      authStatus.textContent = "Session expired. Please log in again.";
      createSnakeBtn.disabled = true;
      applyViewControlAuthState();
    }
    return res;
  }

  async function login() {
    const username = document.getElementById("username").value.trim();
    const password = document.getElementById("password").value.trim();

    const res = await fetch(apiPath("/auth/login"), {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({username, password})
    });

    if (!res.ok) {
      authStatus.textContent = "Login failed";
      return;
    }
    const data = await res.json();
    token = data.token;
    myUserId = data.user_id;
    localStorage.setItem(TOKEN_STORAGE_KEY, token);
    localStorage.setItem(USER_ID_STORAGE_KEY, String(myUserId));

    authStatus.textContent = `Logged in as user_id=${myUserId}`;
    createSnakeBtn.disabled = false;
    applyViewControlAuthState();
    restartStream();

    await loadMySnakes();
  }

  function applyViewControlAuthState() {
    const isAuth = !!token;
    zoomInBtn.disabled = !isAuth;
    zoomOutBtn.disabled = !isAuth;
    zoomResetBtn.disabled = !isAuth;
    publicViewHintEl.style.display = isAuth ? "none" : "inline";
    viewControlsEl.style.opacity = isAuth ? "1" : "0.82";
  }

  async function refreshViewState() {
    try {
      const query = new URLSearchParams({ sid: streamSessionId });
      if (token) query.set("token", token);
      const res = await fetch(apiPath("/game/view?" + query.toString()));
      if (!res.ok) return;
      const data = await res.json();
      if (typeof data.mode === "string") debugModeLabel = data.mode;
      // In AUTH mode, local camera is source of truth unless follow is active.
      const shouldApplyServerCamera = (data.mode !== "AUTH") || !!watchedSnakeId;
      if (shouldApplyServerCamera && typeof data.camera_x === "number" && typeof data.camera_y === "number") {
        camera.setCenter(data.camera_x, data.camera_y);
      }
      if (shouldApplyServerCamera && typeof data.zoom === "number") camera.setZoom(data.zoom);
      if (typeof data.aoi_chunks === "number") serverAoiChunks = data.aoi_chunks;
      if (data.public_camera_chunk && typeof data.public_camera_chunk.cx === "number" && typeof data.public_camera_chunk.cy === "number") {
        debugPublicChunk = { cx: data.public_camera_chunk.cx, cy: data.public_camera_chunk.cy };
      }
      updateDebugOverlay();
    } catch (_) {
      // Best effort debug/state endpoint.
    }
  }

  async function loadMySnakes() {
    if (!token) return;
    const res = await api("/me/snakes");
    if (!res.ok) return;
    const data = await res.json();

    mySnakesEl.innerHTML = "";
    for (const s of data.snakes) {
      const isSelected = s.id === selectedSnakeId;
      const isWatched = s.id === watchedSnakeId;
      const div = document.createElement("div");
      div.className = "snake-item" + (isSelected ? " active" : "");
      div.onclick = () => {
        selectedSnakeId = s.id;
        localStorage.setItem(SELECTED_SNAKE_STORAGE_KEY, String(selectedSnakeId));
        // Selection performs a one-time jump only; it must not start follow.
        const jumpTarget = findSnakeHeadById(selectedSnakeId);
        if (jumpTarget) {
          camera.setCenter(jumpTarget.x, jumpTarget.y);
          centerViewportOnCamera();
          postCamera({ autoFollow: false });
        }
        loadMySnakes();
      };
      div.innerHTML = `
        <span>
          <span><span class="badge" style="background:${s.color}"></span>Snake #${s.id}</span><br />
          <small>
            <label>
              <input class="watch-toggle" type="checkbox" data-sid="${s.id}" ${isWatched ? "checked" : ""} ${isSelected ? "" : "disabled"} />
              watch
            </label>
          </small>
        </span>
        <small>${s.paused ? "paused" : "moving"} · len ${s.len}</small>
      `;
      mySnakesEl.appendChild(div);
    }

    if (!selectedSnakeId && data.snakes.length > 0) selectedSnakeId = data.snakes[0].id;
    if (watchedSnakeId && watchedSnakeId !== selectedSnakeId) watchedSnakeId = null;

    mySnakesEl.querySelectorAll(".watch-toggle").forEach((el) => {
      el.addEventListener("click", async (ev) => {
        ev.stopPropagation();
        const sid = Number(ev.target.getAttribute("data-sid"));
        if (!Number.isFinite(sid)) return;
        if (sid !== selectedSnakeId) return;
        watchedSnakeId = ev.target.checked ? sid : null;
        if (watchedSnakeId) {
          localStorage.setItem(WATCHED_SNAKE_STORAGE_KEY, String(watchedSnakeId));
        } else {
          localStorage.removeItem(WATCHED_SNAKE_STORAGE_KEY);
        }
        await postCamera({ autoFollow: true });
        loadMySnakes();
      });
    });
    mySnakesEl.querySelectorAll("label").forEach((el) => {
      el.addEventListener("click", (ev) => ev.stopPropagation());
    });
  }

  async function createSnake() {
    if (!token) return;
    // random-ish color
    const color = "#" + Math.floor(Math.random()*16777215).toString(16).padStart(6,'0');
    const res = await api("/me/snakes", { method:"POST", body: JSON.stringify({color}) });
    if (!res.ok) {
      const t = await res.text();
      alert("Create snake failed: " + t);
      return;
    }
    await loadMySnakes();
  }

  async function setDir(dir) {
    if (!token || !selectedSnakeId) return;
    await api(`/snakes/${selectedSnakeId}/dir`, { method:"POST", body: JSON.stringify({dir}) });
  }

  async function togglePause() {
    if (!token || !selectedSnakeId) return;
    await api(`/snakes/${selectedSnakeId}/pause`, { method:"POST" });
    await loadMySnakes();
  }

  function isTextEditingTarget(el) {
    if (!el) return false;
    if (el.isContentEditable) return true;
    const tag = (el.tagName || "").toLowerCase();
    if (tag === "textarea" || tag === "select") return true;
    if (tag === "input") {
      const t = (el.type || "text").toLowerCase();
      return !["button","checkbox","color","file","hidden","image","radio","range","reset","submit"].includes(t);
    }
    return false;
  }

  // Input
  document.addEventListener("keydown", async (e) => {
    if (e.ctrlKey || e.metaKey || e.altKey) return;
    if (isTextEditingTarget(document.activeElement) || isTextEditingTarget(e.target)) return;

    const k = e.key.toLowerCase();
    if (["w","a","s","d","p"].includes(k)) e.preventDefault();

    if (k === "w") return setDir(3);
    if (k === "a") return setDir(1);
    if (k === "s") return setDir(4);
    if (k === "d") return setDir(2);
    if (k === "p") return togglePause();
  });

  document.getElementById("loginBtn").onclick = login;
  document.getElementById("createSnakeBtn").onclick = createSnake;

  // SSE stream (watchers scale well)
  function startStream() {
    const params = new URLSearchParams({ sid: streamSessionId });
    if (token) params.set("token", token);
    const es = new EventSource(apiPath("/game/stream?" + params.toString()));
    streamHandle = es;
    es.addEventListener("frame", (ev) => {
      latestSnapshotBytes = new TextEncoder().encode(ev.data).length;
      const state = JSON.parse(ev.data);
      pushStateBuffer(state);
      const view = buildWorldView();
      if (view) drawFrame(view);
      updateDebugOverlay();
    });
    es.onerror = () => {
      // auto reconnect
      es.close();
      setTimeout(startStream, 1000);
    };
  }

  function restartStream() {
    if (streamHandle) {
      streamHandle.close();
      streamHandle = null;
    }
    startStream();
  }

  function findSnakeHeadById(snakeId) {
    if (!latestServerState || !Array.isArray(latestServerState.snakes)) return null;
    if (!snakeId) return null;
    const target = latestServerState.snakes.find((s) => s.id === snakeId);
    if (!target || !Array.isArray(target.body) || target.body.length === 0) return null;
    return { x: target.body[0].x, y: target.body[0].y };
  }

  function getCameraTargetForFollow() {
    const center = { x: Math.floor(gridW / 2), y: Math.floor(gridH / 2) };
    if (!token || !watchedSnakeId) return center;
    return findSnakeHeadById(watchedSnakeId) || center;
  }

  async function postCamera({ autoFollow = true } = {}) {
    if (!token) return;
    try {
      if (autoFollow && watchedSnakeId) {
        const target = getCameraTargetForFollow();
        camera.setCenter(target.x, target.y);
      }
      const res = await api("/game/camera", {
        method: "POST",
        body: JSON.stringify({
          sid: streamSessionId,
          x: Math.round(camera.x),
          y: Math.round(camera.y),
          zoom: camera.zoom,
          watch_snake_id: watchedSnakeId || null
        })
      });
      if (res.ok) {
        const data = await res.json().catch(() => null);
        if (data && typeof data.aoi_chunks === "number") serverAoiChunks = data.aoi_chunks;
      }
      updateDebugOverlay();
    } catch (_) {
      // Optional session camera update. Stream falls back to defaults if this fails.
    }
  }

  function zoomIn() {
    camera.setZoom(camera.zoom * 1.1);
    applyZoomToBoard();
    centerViewportOnCamera();
    postCamera();
  }

  function zoomOut() {
    camera.setZoom(camera.zoom / 1.1);
    applyZoomToBoard();
    centerViewportOnCamera();
    postCamera();
  }

  function resetView() {
    camera.resetToDefault(gridW, gridH);
    if (token && watchedSnakeId) {
      const target = getCameraTargetForFollow();
      camera.setCenter(target.x, target.y);
    }
    applyZoomToBoard();
    centerViewportOnCamera();
    postCamera();
  }

  function centerViewportOnCamera() {
    const side = Math.max(4, Math.round(BASE_CELL_SIZE * camera.zoom));
    const px = camera.x * side + side / 2;
    const py = camera.y * side + side / 2;
    suppressScrollSync = true;
    boardWrap.scrollLeft = Math.max(0, px - boardWrap.clientWidth / 2);
    boardWrap.scrollTop = Math.max(0, py - boardWrap.clientHeight / 2);
    requestAnimationFrame(() => {
      suppressScrollSync = false;
    });
  }

  function syncCameraFromViewport() {
    const side = Math.max(4, Math.round(BASE_CELL_SIZE * camera.zoom));
    if (side <= 0) return;
    const cx = (boardWrap.scrollLeft + boardWrap.clientWidth / 2) / side;
    const cy = (boardWrap.scrollTop + boardWrap.clientHeight / 2) / side;
    camera.setCenter(cx, cy);
  }

  function onBoardWheel(ev) {
    if (!ev.ctrlKey && !ev.metaKey) return;
    ev.preventDefault();
    if (ev.deltaY < 0) {
      zoomIn();
    } else {
      zoomOut();
    }
  }

  if (DEBUG_MODE) {
    debugOverlayEl.style.display = "block";
  }

  zoomInBtn.addEventListener("click", zoomIn);
  zoomOutBtn.addEventListener("click", zoomOut);
  zoomResetBtn.addEventListener("click", resetView);
  board.addEventListener("wheel", onBoardWheel, { passive: false });
  boardWrap.addEventListener("scroll", () => {
    if (suppressScrollSync) return;
    if (token && watchedSnakeId) return; // follow mode controls camera, not manual scroll
    syncCameraFromViewport();
  });

  applyViewControlAuthState();
  if (token && myUserId) {
    authStatus.textContent = `Logged in as user_id=${myUserId}`;
    createSnakeBtn.disabled = false;
    loadMySnakes();
  }
  startStream();
  loadRuntimeSpeed();
  loadEconomyState();
  refreshViewState();
  runtimeSpeedPollTimer = setInterval(loadRuntimeSpeed, 10000);
  economyPollTimer = setInterval(loadEconomyState, 2000);
  viewPollTimer = setInterval(refreshViewState, 1000);
  cameraPollTimer = setInterval(() => {
    if (token) postCamera();
  }, 100);
  if (token) postCamera();
  updateDebugOverlay();
</script>
</body>
</html>
