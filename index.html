<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Online Snake (SSE)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; background: #f8fbf7; color: #1a1a1a; }
    .hero {
      display: flex;
      align-items: center;
      gap: 16px;
      border: 1px solid #d9e6d2;
      border-radius: 12px;
      padding: 14px;
      margin-bottom: 16px;
      background: #ffffff;
    }
    .hero img {
      width: 72px;
      height: 72px;
      object-fit: contain;
      border-radius: 10px;
      background: #eef6e9;
      padding: 6px;
    }
    .hero h1 { margin: 0 0 6px 0; font-size: 26px; }
    .hero p { margin: 0; color: #2f4730; }
    .layout { display: flex; gap: 16px; align-items: flex-start; }
    #left { width: 260px; flex: 0 0 260px; }
    #game { flex: 1; }
    #game-main {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #game-board-wrap {
      overflow: auto;
      max-width: 100%;
      padding-bottom: 4px;
    }

    #game-board {
      display: grid;
      gap: 1px;
      background: #ccc;
      width: max-content;
      user-select: none;
    }
    .cell {
      width: 18px;
      height: 18px;
      background: #f3f3f3;
    }
    .food { background: #ff4444 !important; }

    .snake-cell { background: #00aa00; }

    .panel { border: 1px solid #ddd; padding: 12px; border-radius: 8px; margin-bottom: 12px; }
    .compact-panel {
      margin-bottom: 0;
      padding: 10px;
      background: #ffffff;
    }
    .compact-panel h3 {
      margin: 0 0 8px 0;
      font-size: 15px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px 12px;
    }
    .row { margin: 6px 0; }
    input {
      width: 100%;
      max-width: 100%;
      padding: 6px;
      box-sizing: border-box;
    }
    button { padding: 8px 10px; cursor: pointer; }

    .snake-item {
      border: 1px solid #ddd;
      padding: 8px;
      border-radius: 8px;
      margin: 6px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .snake-item.active { outline: 2px solid #333; }
    .badge { width: 16px; height: 16px; border-radius: 4px; display: inline-block; margin-right: 8px; }
    small { color: #666; }

    @media (max-width: 980px) {
      .layout {
        flex-direction: column;
      }
      #left {
        width: 100%;
        flex: 1 1 auto;
      }
      #game {
        width: 100%;
      }
    }

    @media (max-width: 640px) {
      body {
        margin: 10px;
      }
      .hero {
        flex-direction: column;
        align-items: flex-start;
      }
      .hero img {
        width: 64px;
        height: 64px;
      }
    }
  </style>
</head>
<body>
  <div class="hero">
    <img src="src/images/snake_logo.png" alt="Terrarium Snake Club logo" />
    <div>
      <h1>Terrarium Snake Club</h1>
      <p>Welcome to the new world of gaming! We are currently testing the project, and it will be available very soon. Keep checking back!</p>
    </div>
  </div>

  <div class="layout">
  <div id="left">
    <div class="panel">
      <div class="row"><strong>Login (optional)</strong></div>
      <div class="row"><input id="username" placeholder="username (user1)" /></div>
      <div class="row"><input id="password" type="password" placeholder="password (pass1)" /></div>
      <div class="row"><button id="loginBtn">Login</button></div>
      <div class="row"><small id="authStatus">Not logged in (watch-only)</small></div>
    </div>

    <div class="panel">
      <div class="row"><strong>My Snakes</strong></div>
      <div id="mySnakes"></div>
      <div class="row"><button id="createSnakeBtn" disabled>Create Snake</button></div>
      <div class="row"><small>Controls: W/A/S/D move selected snake, P pause selected snake</small></div>
    </div>
  </div>

  <div id="game">
    <div id="game-main">
      <div class="panel compact-panel">
        <h3>Economy (Read-Only)</h3>
        <div class="stats-grid">
          <div title="Total issued cells">Money Supply (M): <span id="ecoM">—</span></div>
          <div title="Cost multiplier (read-only for now)">Price Index (P): <span id="ecoP">—</span></div>
          <div title="Money growth this period">Inflation (pi): <span id="ecoPi">—</span></div>
          <div title="World area implied by money supply">World Size (A_world): <span id="ecoAWorld">—</span></div>
          <div title="Slack capacity">Free Space (M_white): <span id="ecoMWhite">—</span></div>
        </div>
      </div>
      <div id="game-board-wrap">
        <div id="game-board"></div>
      </div>
      <div class="panel compact-panel">
        <h3>Live Game</h3>
        <div class="stats-grid">
          <div>Tick: <span id="tick">0</span></div>
          <div>Expected speed: <span id="expectedTickHz">-</span> tick/s</div>
          <div>Actual speed: <span id="actualTickHz">-</span> tick/s</div>
          <div><small id="ecoStatus">Economy: loading...</small></div>
        </div>
      </div>
    </div>
  </div>
  </div>

<script>
  const API_BASE = window.location.protocol === "file:" ? "http://127.0.0.1:8080" : "";
  const apiPath = (path) => `${API_BASE}${path}`;

  let token = null;
  let myUserId = null;
  let selectedSnakeId = null;
  let watchedSnakeId = null;
  let latestServerState = null;
  const stateBuffer = [];
  const streamSessionId = (window.crypto && crypto.randomUUID)
    ? crypto.randomUUID()
    : ("sid_" + Math.random().toString(36).slice(2));

  let gridW = 40, gridH = 20;
  let cells = [];

  const board = document.getElementById("game-board");
  const tickEl = document.getElementById("tick");
  const expectedTickHzEl = document.getElementById("expectedTickHz");
  const actualTickHzEl = document.getElementById("actualTickHz");
  const ecoMEl = document.getElementById("ecoM");
  const ecoPEl = document.getElementById("ecoP");
  const ecoPiEl = document.getElementById("ecoPi");
  const ecoAWorldEl = document.getElementById("ecoAWorld");
  const ecoMWhiteEl = document.getElementById("ecoMWhite");
  const ecoStatusEl = document.getElementById("ecoStatus");
  const authStatus = document.getElementById("authStatus");
  const mySnakesEl = document.getElementById("mySnakes");
  const createSnakeBtn = document.getElementById("createSnakeBtn");

  let lastTickSample = null;
  let expectedTickHz = null;
  const FALLBACK_EXPECTED_TICK_HZ = 10;
  let runtimeSpeedPollTimer = null;
  let economyPollTimer = null;
  let cameraPollTimer = null;

  function buildBoard(w, h) {
    gridW = w; gridH = h;
    board.style.gridTemplateColumns = `repeat(${w}, 18px)`;
    board.innerHTML = "";
    cells = [];
    for (let i = 0; i < w*h; i++) {
      const c = document.createElement("div");
      c.className = "cell";
      board.appendChild(c);
      cells.push(c);
    }
  }

  function idx(x,y){ return y*gridW + x; }

  function clearBoard() {
    for (const c of cells) {
      c.className = "cell";
      c.style.background = ""; // allow custom snake colors
    }
  }

  function drawFrame(state) {
    latestServerState = state;
    tickEl.textContent = state.tick;
    updateActualTickHz(state.tick);

    if (state.w !== gridW || state.h !== gridH || cells.length === 0) {
      buildBoard(state.w, state.h);
    }

    clearBoard();

    // foods
    for (const f of state.foods) {
      const i = idx(f.x, f.y);
      if (cells[i]) cells[i].classList.add("food");
    }

    // snakes
    for (const s of state.snakes) {
      for (const seg of s.body) {
        const i = idx(seg.x, seg.y);
        if (!cells[i]) continue;
        cells[i].classList.add("snake-cell");
        // color each snake
        cells[i].style.background = s.color;
      }
    }
  }

  function pushStateBuffer(state) {
    stateBuffer.push({ state, t: performance.now() });
    if (stateBuffer.length > 2) stateBuffer.shift();
  }

  function buildWorldView() {
    // v1 view layer: keep ring buffer ready for interpolation, render latest snapshot for now.
    if (stateBuffer.length === 0) return null;
    return stateBuffer[stateBuffer.length - 1].state;
  }

  function updateActualTickHz(currentTick) {
    const now = performance.now();
    if (!lastTickSample) {
      lastTickSample = { tick: currentTick, t: now };
      return;
    }

    const dtMs = now - lastTickSample.t;
    const dTick = currentTick - lastTickSample.tick;
    if (dtMs >= 800 && dTick >= 0) {
      const hz = dTick / (dtMs / 1000);
      actualTickHzEl.textContent = hz.toFixed(2);
      lastTickSample = { tick: currentTick, t: now };
    }
  }

  async function loadRuntimeSpeed() {
    try {
      const res = await fetch(apiPath("/game/runtime"));
      if (!res.ok) throw new Error("runtime endpoint unavailable");
      const data = await res.json();
      if (typeof data.tick_hz === "number" && data.tick_hz > 0) {
        expectedTickHz = data.tick_hz;
        expectedTickHzEl.textContent = String(expectedTickHz);
        return;
      }
      throw new Error("runtime endpoint missing tick_hz");
    } catch (_) {
      // Fallback keeps local/prod UI readable when talking to an older backend binary.
      expectedTickHz = FALLBACK_EXPECTED_TICK_HZ;
      expectedTickHzEl.textContent = `${expectedTickHz} (fallback)`;
      // Stop repeated failing polls on older binaries that do not expose /game/runtime.
      if (runtimeSpeedPollTimer) {
        clearInterval(runtimeSpeedPollTimer);
        runtimeSpeedPollTimer = null;
      }
    }
  }

  function setEconomyFallback() {
    ecoMEl.textContent = "—";
    ecoPEl.textContent = "—";
    ecoPiEl.textContent = "—";
    ecoAWorldEl.textContent = "—";
    ecoMWhiteEl.textContent = "—";
    ecoStatusEl.textContent = "Economy unavailable";
  }

  function fmtInt(v) {
    if (!Number.isFinite(v)) return "—";
    return Math.trunc(v).toLocaleString();
  }

  async function loadEconomyState() {
    try {
      const res = await fetch(apiPath("/economy/state"));
      if (!res.ok) throw new Error("economy endpoint unavailable");
      const s = await res.json();
      ecoMEl.textContent = fmtInt(Number(s.M));
      ecoPEl.textContent = Number.isFinite(Number(s.P)) ? Number(s.P).toFixed(3) : "—";
      ecoPiEl.textContent = Number.isFinite(Number(s.pi)) ? Number(s.pi).toFixed(4) : "—";
      ecoAWorldEl.textContent = fmtInt(Number(s.A_world));
      ecoMWhiteEl.textContent = fmtInt(Number(s.M_white));
      ecoStatusEl.textContent = "Economy: live";
    } catch (_) {
      setEconomyFallback();
    }
  }

  async function api(path, opts={}) {
    const headers = opts.headers || {};
    headers["Content-Type"] = "application/json";
    if (token) headers["Authorization"] = "Bearer " + token;
    const res = await fetch(apiPath(path), { ...opts, headers });
    return res;
  }

  async function login() {
    const username = document.getElementById("username").value.trim();
    const password = document.getElementById("password").value.trim();

    const res = await fetch(apiPath("/auth/login"), {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({username, password})
    });

    if (!res.ok) {
      authStatus.textContent = "Login failed";
      return;
    }
    const data = await res.json();
    token = data.token;
    myUserId = data.user_id;

    authStatus.textContent = `Logged in as user_id=${myUserId}`;
    createSnakeBtn.disabled = false;

    await loadMySnakes();
  }

  async function loadMySnakes() {
    if (!token) return;
    const res = await api("/me/snakes");
    if (!res.ok) return;
    const data = await res.json();

    mySnakesEl.innerHTML = "";
    for (const s of data.snakes) {
      const isSelected = s.id === selectedSnakeId;
      const isWatched = s.id === watchedSnakeId;
      const div = document.createElement("div");
      div.className = "snake-item" + (isSelected ? " active" : "");
      div.onclick = () => {
        selectedSnakeId = s.id;
        if (watchedSnakeId && watchedSnakeId !== selectedSnakeId) watchedSnakeId = null;
        loadMySnakes();
      };
      div.innerHTML = `
        <span>
          <span><span class="badge" style="background:${s.color}"></span>Snake #${s.id}</span><br />
          <small>
            <label>
              <input class="watch-toggle" type="checkbox" data-sid="${s.id}" ${isWatched ? "checked" : ""} ${isSelected ? "" : "disabled"} />
              watch
            </label>
          </small>
        </span>
        <small>${s.paused ? "paused" : "moving"} · len ${s.len}</small>
      `;
      mySnakesEl.appendChild(div);
    }

    if (!selectedSnakeId && data.snakes.length > 0) selectedSnakeId = data.snakes[0].id;
    if (watchedSnakeId && watchedSnakeId !== selectedSnakeId) watchedSnakeId = null;

    mySnakesEl.querySelectorAll(".watch-toggle").forEach((el) => {
      el.addEventListener("click", async (ev) => {
        ev.stopPropagation();
        const sid = Number(ev.target.getAttribute("data-sid"));
        if (!Number.isFinite(sid)) return;
        if (sid !== selectedSnakeId) return;
        watchedSnakeId = ev.target.checked ? sid : null;
        await postCamera();
        loadMySnakes();
      });
    });
  }

  async function createSnake() {
    if (!token) return;
    // random-ish color
    const color = "#" + Math.floor(Math.random()*16777215).toString(16).padStart(6,'0');
    const res = await api("/me/snakes", { method:"POST", body: JSON.stringify({color}) });
    if (!res.ok) {
      const t = await res.text();
      alert("Create snake failed: " + t);
      return;
    }
    await loadMySnakes();
  }

  async function setDir(dir) {
    if (!token || !selectedSnakeId) return;
    await api(`/snakes/${selectedSnakeId}/dir`, { method:"POST", body: JSON.stringify({dir}) });
  }

  async function togglePause() {
    if (!token || !selectedSnakeId) return;
    await api(`/snakes/${selectedSnakeId}/pause`, { method:"POST" });
    await loadMySnakes();
  }

  function isTextEditingTarget(el) {
    if (!el) return false;
    if (el.isContentEditable) return true;
    const tag = (el.tagName || "").toLowerCase();
    if (tag === "textarea" || tag === "select") return true;
    if (tag === "input") {
      const t = (el.type || "text").toLowerCase();
      return !["button","checkbox","color","file","hidden","image","radio","range","reset","submit"].includes(t);
    }
    return false;
  }

  // Input
  document.addEventListener("keydown", async (e) => {
    if (e.ctrlKey || e.metaKey || e.altKey) return;
    if (isTextEditingTarget(document.activeElement) || isTextEditingTarget(e.target)) return;

    const k = e.key.toLowerCase();
    if (["w","a","s","d","p"].includes(k)) e.preventDefault();

    if (k === "w") return setDir(3);
    if (k === "a") return setDir(1);
    if (k === "s") return setDir(4);
    if (k === "d") return setDir(2);
    if (k === "p") return togglePause();
  });

  document.getElementById("loginBtn").onclick = login;
  document.getElementById("createSnakeBtn").onclick = createSnake;

  // SSE stream (watchers scale well)
  function startStream() {
    const es = new EventSource(apiPath("/game/stream?sid=" + encodeURIComponent(streamSessionId)));
    es.addEventListener("frame", (ev) => {
      const state = JSON.parse(ev.data);
      pushStateBuffer(state);
      const view = buildWorldView();
      if (view) drawFrame(view);
    });
    es.onerror = () => {
      // auto reconnect
      es.close();
      setTimeout(startStream, 1000);
    };
  }

  function getCameraTarget() {
    const center = { x: Math.floor(gridW / 2), y: Math.floor(gridH / 2) };
    if (!watchedSnakeId || !latestServerState || !Array.isArray(latestServerState.snakes)) return center;
    const target = latestServerState.snakes.find((s) => s.id === watchedSnakeId);
    if (!target || !Array.isArray(target.body) || target.body.length === 0) return center;
    return { x: target.body[0].x, y: target.body[0].y };
  }

  async function postCamera() {
    try {
      const target = getCameraTarget();
      await fetch(apiPath("/game/camera"), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sid: streamSessionId,
          x: target.x,
          y: target.y,
          watch_snake_id: watchedSnakeId || null
        })
      });
    } catch (_) {
      // Optional session camera update. Stream falls back to defaults if this fails.
    }
  }

  startStream();
  loadRuntimeSpeed();
  loadEconomyState();
  runtimeSpeedPollTimer = setInterval(loadRuntimeSpeed, 10000);
  economyPollTimer = setInterval(loadEconomyState, 2000);
  cameraPollTimer = setInterval(postCamera, 400);
  postCamera();
</script>
</body>
</html>
